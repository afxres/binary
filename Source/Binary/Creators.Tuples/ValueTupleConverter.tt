<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;

namespace Mikodev.Binary.Creators.Tuples
{
<#
static IEnumerable<T> Map<T>(int start, int count, Func<int, T> func) => Enumerable.Range(start, count).Select(func);

var prefix = "ValueTuple";
var member = new List<string>(Map(1, 7, x => $"Item{x}")) { "Rest" }.ToArray();

for (var i = 1; i <= 8; i++)
{
    string Join(string name) => string.Join(", ", Map(1, i, x => $"{name}{x}"));
    var typeArguments = Join("T");
    var typeName = $"{prefix}<{typeArguments}>";
    var typeConstraints = i == 8 ? " where T8 : struct" : "";
    var fieldPrefix = "converter";
    if (i != 1)
    {
#>

<#
    }
#>
    internal sealed class <#= prefix #>Converter<<#= typeArguments #>> : TupleLikeConverter<<#= typeName #>><#= typeConstraints #>
    {
<#
    for (var k = 1; k <= i; k++)
    {
#>
        private readonly Converter<T<#= k #>> <#= fieldPrefix #><#= k #>;

<#
    }
#>
        public <#= prefix #>Converter(<#= string.Join(", ", Map(1, i, x => $"Converter<T{x}> {fieldPrefix}{x}")) #>, int length) : base(length)
        {
<#
    for (var k = 1; k <= i; k++)
    {
#>
            this.<#= fieldPrefix #><#= k #> = <#= fieldPrefix #><#= k #>;
<#
    }
#>
        }
<#
    foreach (var method in (new[] { "", "Auto" }))
    {
#>

        public override void Encode<#= method #>(ref Allocator allocator, <#= typeName #> item)
        {
<#
        for (var k = 1; k <= i; k++)
        {
            var before = k != i || method != "";
            var suffix = before ? "Auto" : "";
#>
            <#= fieldPrefix #><#= k #>.Encode<#= suffix #>(ref allocator, item.<#= member[k - 1] #>);
<#
        }
#>
        }

        public override <#= typeName #> Decode<#= method #>(<#= (method == "" ? "in" : "ref") #> ReadOnlySpan<byte> span)
        {
            var item = new <#= typeName #>();
<#
        var origin = method == "";
        var source = origin ? "body" : "span";
        if (origin)
        {
#>
            var body = span;
<#
        }
        for (var k = 1; k <= i; k++)
        {
            var before = k != i || method != "";
            var suffix = before ? "Auto" : "";
#>
            item.<#= member[k - 1] #> = <#= fieldPrefix #><#= k #>.Decode<#= suffix #>(<#= (before ? "ref" : "in") #> <#= source #>);
<#
        }
#>
            return item;
        }
<#
    }
#>
    }
<#
}
#>
}
